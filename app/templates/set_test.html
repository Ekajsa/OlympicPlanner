<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        td {
            width: 25px;
            height: 25px;
            border: 1px solid black;
        }

        .click-me {
            background-color: green;
            width: 23px;
            height: 23px;
        }
    </style>
</head>

<body>
    <table id="the-table">
        <tr>
            <td></td>
            <td rowspan=2>
                <div class="click-me"></div>
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>

            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td rowspan=3>
                <div class="click-me"></div>
            </td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <div class="click-me"></div>

            </td>
            
            <td>
                
            </td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>


    <script>

        // Generate table with true/false if cells are occupied
        // Använd din emptySlots istället för detta om du vill
        function tableToMatrix(table) {
            let M = [];
            for (let i = 0; i < table.rows.length; i++) {
                let tr = table.rows[i];
                M[i] = [];
                for (let j = 0, k = 0; j < M[0].length || k < tr.cells.length;) {
                    let c = (M[i - 1] || [])[j];
                    // first check if there's a continuing cell above with rowSpan
                    if (c && c.parentNode.rowIndex + c.rowSpan > i) {
                        M[i].push(...Array.from({ length: c.colSpan }, () => c))
                        j += c.colSpan;
                    } else if (tr.cells[k]) {
                        let td = tr.cells[k++];
                        M[i].push(...Array.from({ length: td.colSpan }, () => td));
                        j += td.colSpan;
                    }
                }
            }
            return M;
        }

        let M = tableToMatrix(document.querySelector('table'));

        M =  M.map(r => r.map(c => (elementIsEmpty(c) ? true: false)));


        // Ända hit

        //*********

        // Add event listeners for all 
        let events = document.getElementsByClassName("click-me");

        function clickEvent(e) {
            // Get the table
            let table = document.getElementById("the-table");

            // Calculate the start and end row for the clicked event
            let clickedStartRow = e.path[2].rowIndex;
            let clickedEndRow = e.path[1].rowSpan + clickedStartRow - 1;

            // Generate a set with the rows in the clicked event
            let sequenceClicked = [];
            for (let i = clickedStartRow; i <= clickedEndRow; i++) {
                sequenceClicked.push(i);
            }
            let clickedColumn = new Set(sequenceClicked);

            // Get the rows for the checked column and store it in a set
            for (let col = 1; col < 6; col++) {
                let sequenceChecked = [];
                for (let row = 0; row <= clickedEndRow; row++) {

                    if(!M[row][col]) {
                        // If we need to check if the current event is the clicked
                        // But do we want that???
                        if(table.rows[row].cells[col]=== e.path[1]) {
                             console.log(row, col, "Me");
                         }
                        sequenceChecked.push(row);
                    }
                }
                
                let checkedColumn = new Set(sequenceChecked);

                // If we have an intersection we can't place the selected event in
                // this column
                if(intersection(clickedColumn, checkedColumn).size > 0) {
                    //console.log("Can't place in column ", col);
                }
                else {
                    // But here we can. Yay!!!!
                    console.log("Can place in column ", col);
                    // Move it here
                    break;
                }
            }
        }


        // Attach the event listeners for the click event on all divs
        for (let i = 0; i < events.length; i++) {
            events[i].addEventListener('click', clickEvent, false);
        }


        // Function to check set intersections
        function intersection(setA, setB) {
            let _intersection = new Set()
            for (let elem of setB) {
                if (setA.has(elem)) {
                    _intersection.add(elem)
                }
            }
            return _intersection
        }

        // Function to check if a cell in the table is empty
        function elementIsEmpty(el) {
            return (/^(\s|&nbsp;)*$/.test(el.innerHTML));
        }
    </script>
</body>

</html>